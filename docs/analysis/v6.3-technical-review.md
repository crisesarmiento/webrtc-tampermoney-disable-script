# M-Game Clean Audio v6.3 — Technical Review & Reference

## Document Purpose

This document is a code review and technical analysis of the current v6.3 Tampermonkey script. It identifies confirmed bugs, architectural risks, and areas for improvement. Use this alongside the project instructions and technical reference documents for full context.

---

## 1. CONFIRMED BUGS

### BUG 1: `mgameGain()` does nothing at runtime (CRITICAL)

**The problem**: The `mgameGain(n)` console command updates the variable `currentGain`, but **never touches the actual GainNode's AudioParam**. The GainNode is created inside `buildProcessingChain()` (line 160), gets `gain.gain.value = currentGain` at creation time (line 163), but is never stored anywhere accessible. The `nodes` object containing the gain reference is returned from `buildProcessingChain` but immediately destructured to only extract `output` (line 207):

```javascript
const { output } = buildProcessingChain(ctx, source);  // nodes.gain is discarded!
```

After this point, there is no reference to the GainNode anywhere. `mgameGain()` updates `currentGain` but that variable is only read once — when the chain is first built.

**Expected behavior**: Calling `mgameGain(1.5)` should immediately change the gain of the live audio stream.

**Fix**: Store the GainNode reference at module scope and update its AudioParam in the `mgameGain()` function:

```javascript
let activeGainNode = null;  // module scope

// In buildProcessingChain or replaceFirstAudioTrackWithProcessed:
activeGainNode = nodes.gain;

// In mgameGain():
window.mgameGain = function (value) {
    if (value === undefined) { /* ... */ }
    currentGain = Math.max(0.0, Math.min(3.0, Number(value)));
    if (activeGainNode) {
        activeGainNode.gain.value = currentGain;
    }
    // ...
};
```

Compare to v5.2 which correctly stored `gainNode` at module scope and updated it.

---

### BUG 2: Soft clipper curve reduces overall volume by ~40% (SIGNIFICANT)

**The problem**: The waveshaper curve formula at line 153:

```javascript
curve[i] = Math.tanh(x / k) * k;   // k = 0.65
```

This produces these input→output mappings:
| Input sample | Output sample | Volume loss |
|-------------|--------------|-------------|
| 1.0 (peak) | ~0.59 | **-41%** |
| 0.5 | ~0.42 | -16% |
| 0.25 | ~0.24 | -4% |
| 0.1 | ~0.10 | ~0% |

The curve caps maximum output at ~0.59 (k × tanh(1/k)) instead of 1.0. This means even properly-leveled audio gets its peaks chopped to 59% of original. It also introduces nonlinearity (harmonic distortion) on signals well below clipping threshold — at 0.5 input, the output is 0.42 instead of the expected 0.5.

**What a proper soft clipper should do**: Be transparent (linear, y=x) for small/moderate signals, and only saturate near the ceiling. A better approach:

```javascript
// Linear below threshold, tanh saturation above
const threshold = 0.8;
if (Math.abs(x) < threshold) {
    curve[i] = x;  // transparent
} else {
    const excess = (Math.abs(x) - threshold) / (1 - threshold);
    const clipped = threshold + (1 - threshold) * Math.tanh(excess * 2);
    curve[i] = Math.sign(x) * clipped;
}
```

**Impact**: Listeners hear quieter audio than expected. The gain loss stacks with compression and limiting, potentially making the stream too quiet. The user might compensate by boosting `mgameGain()` (if Bug 1 were fixed), which then drives the compressor harder, creating a vicious cycle.

---

### BUG 3: `setInterval` calls `setParameters()` every 2 seconds (RISK)

**The problem**: Lines 373-376 create a 2-second interval per PeerConnection:

```javascript
const periodic = setInterval(() => {
    if (pc.connectionState === 'closed') return clearInterval(periodic);
    if (pc.connectionState === 'connected') refreshAudioSenders(pc);
}, 2000);
```

`refreshAudioSenders` calls `sender.getParameters()` + `sender.setParameters()` on every audio sender, every 2 seconds. Per the WebRTC spec, `setParameters()` can trigger encoder reconfiguration. Depending on Chrome's implementation:

- Could cause brief audio glitches/dropouts during reconfiguration
- Could reset internal Opus encoder state (kills the SILK→CELT mode transition that's been building up)
- The `setParameters` call silently swallows errors (`.catch(() => {})`), so failures are invisible

**What it's trying to do**: Ensure `maxBitrate` stays set and `contentHint` stays as 'music' in case X Spaces resets them.

**Better approach**: Set once at `addTrack`/`addTransceiver` time (which v6.3 already does), and only re-apply if a `track` event or renegotiation is detected, not on a blind timer. Or at minimum, check if the value is already correct before calling `setParameters()`:

```javascript
const p = sender.getParameters();
if (p.encodings?.[0]?.maxBitrate !== TARGET_AUDIO_MAX_BITRATE_BPS) {
    p.encodings[0].maxBitrate = TARGET_AUDIO_MAX_BITRATE_BPS;
    sender.setParameters(p);
}
```

---

## 2. ARCHITECTURAL CONCERNS

### CONCERN 1: RTCPeerConnection constructor wrapping

**What changed**: v5.2 only hooked prototype methods (safe). v6.3 replaces the constructor entirely (line 365):

```javascript
window.RTCPeerConnection = function (...args) {
    const pc = new OriginalPC(...args);
    // ... per-instance patching ...
    return pc;
};
window.RTCPeerConnection.prototype = OriginalPC.prototype;
```

**Why it was done**: To hook `addTrack`/`addTransceiver` per-instance and to track all PeerConnections in a Set.

**Risk assessment**: The pattern is actually MOSTLY safe because:
- The returned `pc` IS a real `OriginalPC` instance
- `instanceof` checks work because prototype is preserved
- Static properties like `generateCertificate` may be lost (should copy them)

**However**, per-instance method replacement (lines 379-404) replaces `pc.addTrack` and `pc.addTransceiver` with wrapper functions. If X Spaces stores a reference to these methods before our wrapper is installed, or checks `hasOwnProperty('addTrack')`, behavior could differ.

**Missing**: Static method forwarding. If X Spaces calls `RTCPeerConnection.generateCertificate()`, it will fail. Add:

```javascript
Object.keys(OriginalPC).forEach(k => {
    if (!(k in window.RTCPeerConnection)) {
        window.RTCPeerConnection[k] = OriginalPC[k];
    }
});
```

---

### CONCERN 2: Compressor settings may be too aggressive for music-only streaming

**Current settings**:
- Compressor: threshold -18dB, ratio 3:1, knee 12dB, attack 6ms, release 180ms
- Limiter: threshold -3.5dB, ratio 20:1, knee 0dB, attack 2ms, release 80ms

**Analysis**: The -18dB threshold means virtually ALL music content (which typically sits around -12 to -6dBFS) is being compressed at 3:1. This is moderate broadcast-style compression, appropriate for "voice + music mixed" scenarios where you need voice to cut through.

BUT if the use case is **music-only** (no voice), this is too much compression. It flattens the dynamics that make music engaging. The compressor should either:
- Be bypassed for music-only sessions
- Have a higher threshold (e.g., -10dB) so only peaks are affected
- Be configurable at runtime (like gain is supposed to be)

**The limiter** at -3.5dB with 20:1 ratio is reasonable as a safety ceiling.

**The processing chain order** is correct: Gain → Compressor → Limiter → Soft Clip. This is standard broadcast chain.

---

### CONCERN 3: Memory leak — PeerConnections never removed from Set

Line 362: `const pcs = new Set()`. Line 367: `pcs.add(pc)`. PeerConnections are added but never removed, even when closed. The `setInterval` clears itself on 'closed', but the Set reference keeps the PC object alive in memory. For long sessions with reconnections, this accumulates.

**Fix**: Add cleanup in the connectionstatechange listener:

```javascript
pc.addEventListener('connectionstatechange', () => {
    if (pc.connectionState === 'closed') {
        pcs.delete(pc);
    }
});
```

---

### CONCERN 4: `disableProcessing` called on MediaStreamDestination tracks

In `processStream()` (line 246), `disableProcessing()` is called on the processed track (which comes from `ctx.createMediaStreamDestination()`). This track is a Web Audio API output, not a getUserMedia capture track. Calling `applyConstraints(W3C_AUDIO)` on it may:
- Do nothing (no processing to disable on a synthesis track)
- Throw in some browsers (the `.catch(() => {})` handles this)
- Add unnecessary async overhead

This is harmless but wasteful. The meaningful constraint work happens on the original capture track via `modifyConstraints()` at getUserMedia time.

---

## 3. SIGNAL CHAIN ANALYSIS

### Current audio path (v6.3):

```
RØDE M-Game USB → Chrome capture (goog* disabled) → GainNode → Compressor → Limiter → Soft Clipper → MediaStreamDestination → WebRTC Opus Encoder (fullband, VBR, 128kbps)
```

### Signal level journey:

1. **M-Game output**: Nominally 0 to -1dBFS (USB audio interface typically outputs near full scale)
2. **GainNode** (default 1.0x): No change
3. **Compressor** (-18dB threshold, 3:1): Most of the signal is above -18dB, so compression is always active. A signal at -6dBFS gets reduced by (6-18)/3 × (1 - 1/3) = 8dB of gain reduction (approximate, knee affects this). Output: roughly -14dBFS
4. **Limiter** (-3.5dB threshold, 20:1): Only catches extreme peaks. Mostly transparent if compressor is doing its job.
5. **Soft clipper** (k=0.65): Reduces peak by ~41%. A -3dBFS signal (0.71 linear) becomes ~0.50 linear (-6dBFS). **This is a 3dB loss on top of compression.**
6. **Opus encoder**: Receives a significantly quieter signal than the original. With VBR, this means fewer bits allocated (less complex signal), potentially reducing quality.

### Net effect on listener:
Music arrives quieter than source, with reduced dynamics (compressor) and reduced peak headroom (soft clipper). If the original goal was to fix "too loud" issues, the compression approach works but the soft clipper is over-contributing.

---

## 4. COMPARISON: v5.2 → v6.3

| Feature | v5.2 | v6.3 | Assessment |
|---------|------|------|------------|
| Audio processing disabled | ✅ W3C + goog* | ✅ W3C + goog* | Same, correct |
| SDP fullband params | ✅ All 7 params | ✅ All 7 params | Same, correct |
| VBR (no CBR) | ✅ cbr deleted | ✅ cbr deleted | Same, correct |
| GainNode | ✅ Runtime adjustable | ❌ **Broken** — gain changes don't apply | Regression |
| Compressor | ❌ None | ✅ Added | New feature, settings debatable |
| Limiter | ❌ None | ✅ Added | New feature, reasonable |
| Soft Clipper | ❌ None | ✅ Added | New feature, **volume bug** |
| RTCPeerConnection wrapping | ❌ Prototype only | ✅ Constructor wrap | Riskier, needed for sender bitrate |
| Sender bitrate hint | ❌ None | ✅ setParameters | New feature, useful |
| Periodic sender refresh | ❌ None | ✅ Every 2s | **Risky** — can cause glitches |
| mgameStatus() | ✅ Available | ❌ Removed | Lost debuggability |
| contentHint refresh | ❌ One-time | ✅ setTimeout 250ms + periodic | More robust |
| AudioContext resume | ❌ None | ✅ User gesture handling | Good improvement |

---

## 5. RECOMMENDED FIXES (PRIORITY ORDER)

### P0 — Fix mgameGain() (Bug 1)
Store GainNode at module scope. Update AudioParam in real-time.

### P0 — Fix soft clipper curve (Bug 2)
Either: make it transparent below a threshold (e.g., linear below 0.8, tanh above), or disable it and rely on the limiter alone (which is already set at -3.5dB).

### P1 — Guard setParameters() polling (Bug 3)
Only call `setParameters()` when the value actually differs from current. Or replace the interval with event-driven approach (listen for `negotiationneeded`, `track` events).

### P1 — Add mgameStatus() back
Essential for debugging. Should show: current gain, compressor reduction, limiter reduction, AudioContext state, connected PeerConnections count, actual sender bitrate.

### P2 — Add runtime compressor bypass
Allow `mgameComp(false)` to disable compressor for music-only sessions. Currently requires editing the script.

### P2 — Clean up PeerConnection Set
Remove closed connections to prevent memory leaks.

### P3 — Copy static RTCPeerConnection methods
Forward `generateCertificate` and any other static methods from OriginalPC.

---

## 6. TESTING CHECKLIST

When verifying changes, check these in `chrome://webrtc-internals`:

1. **Codec mode**: Should show opus, verify it's running fullband (48kHz)
2. **Bitrate**: Should vary (VBR) around 128kbps average, spiking on complex passages
3. **SDP offer/answer**: Verify all 7 OPUS_MUSIC_PARAMS are present in both directions
4. **Audio level**: Compare outbound audio level with and without soft clipper enabled
5. **Sender parameters**: Verify `maxBitrate=128000` in sender encodings

### Listener perception tests:
- Play music only → should sound full, not compressed or quiet
- Talk over music → voice should be clear, music shouldn't duck dramatically
- Silence → no cutting or artifacts (usedtx=0 working)
- Quiet passages → should remain quiet, not pumped up (AGC disabled)
- Loud passages → limited at ceiling, not distorted

---

## 7. KEY CONSTANTS REFERENCE

```
COMPRESSOR: threshold=-18dB, knee=12dB, ratio=3:1, attack=6ms, release=180ms
LIMITER:    threshold=-3.5dB, knee=0dB, ratio=20:1, attack=2ms, release=80ms
SOFT CLIP:  k=0.65 (tanh curve, introduces ~41% peak loss)
GAIN:       default=1.0x, range=0.0-3.0x (CURRENTLY BROKEN AT RUNTIME)
BITRATE:    128kbps target (SDP + sender encoding)
SDP PARAMS: maxplaybackrate=48000, sprop-maxcapturerate=48000, stereo=1,
            sprop-stereo=1, usedtx=0, useinbandfec=1, VBR (no cbr)
```
